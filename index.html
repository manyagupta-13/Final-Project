<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Escape Room: The Abandoned Laboratory</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background-color: #000;
            color: #e0e0e0;
        }
        
        #threejs-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #ui-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            max-height: 30vh;
            overflow-y: auto;
            border: 1px solid #444;
            z-index: 2;
        }
        
        #inventory {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            width: 200px;
            border: 1px solid #444;
            z-index: 2;
        }
        
        #inventory h3 {
            margin-top: 0;
            color: #8bc34a;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }
        
        #inventory-items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .inventory-item {
            background-color: rgba(68, 68, 68, 0.8);
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 0.9rem;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background-color: #222;
            padding: 30px;
            border-radius: 5px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 2px solid #444;
            position: relative;
        }
        
        .modal-close {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #aaa;
            font-size: 24px;
            cursor: pointer;
        }
        
        .modal-close:hover {
            color: #fff;
        }
        
        .interaction-buttons {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .interaction-button {
            background-color: #4a4a4a;
            color: #e0e0e0;
            border: none;
            padding: 8px 15px;
            border-radius: 3px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        
        .interaction-button:hover {
            background-color: #5a5a5a;
        }
        
        .interaction-button:disabled {
            background-color: #333;
            color: #777;
            cursor: not-allowed;
        }
        
        .keypad {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            gap: 10px;
            margin: 20px auto;
            width: fit-content;
        }
        
        .keypad button {
            width: 60px;
            height: 60px;
            font-size: 1.5rem;
        }
        
        .keypad-display {
            grid-column: span 3;
            background-color: #111;
            color: #f00;
            padding: 10px;
            text-align: center;
            font-family: monospace;
            font-size: 1.5rem;
            border: 1px solid #333;
            margin-bottom: 10px;
        }
        
        .success {
            color: #8bc34a;
        }
        
        .error {
            color: #f44336;
        }
        
        .hint {
            color: #aaa;
            font-style: italic;
            font-size: 0.9rem;
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        .pulsing {
            animation: pulse 2s infinite;
        }

        /* Crossword Puzzle Styles */
        .crossword-container {
            background-color: #333;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
        
        .crossword-grid {
            display: grid;
            grid-template-columns: repeat(5, 40px);
            grid-template-rows: repeat(5, 40px);
            gap: 2px;
            margin: 20px auto;
            justify-content: center;
        }
        
        .crossword-cell {
            width: 40px;
            height: 40px;
            background-color: #444;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .crossword-cell input {
            width: 100%;
            height: 100%;
            background: transparent;
            border: none;
            color: #fff;
            font-size: 20px;
            text-align: center;
            text-transform: uppercase;
        }
        
        .crossword-cell input:focus {
            outline: 1px solid #8bc34a;
        }
        
        .crossword-clues {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
        }
        
        .clue-list {
            width: 45%;
        }
        
        .clue-number {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 10px;
            color: #8bc34a;
        }
        
        .crossword-success {
            color: #8bc34a;
            font-weight: bold;
            text-align: center;
            margin: 20px 0;
            display: none;
        }

        /* Anagram Puzzle Styles */
        .anagram-letters {
            font-size: 24px;
            letter-spacing: 5px;
            margin: 20px 0;
            padding: 10px;
            background: #333;
            border-radius: 5px;
        }

        #anagram-feedback {
            margin-top: 15px;
            min-height: 30px;
        }
        .connections-game {
    margin: 20px 0;
}

.connections-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
    margin-bottom: 20px;
}

.connections-card {
    background-color: #f5f5f5;
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 15px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s;
}

.connections-card.selected {
    background-color: #8bc34a;
    color: white;
}

.connections-selected {
    margin-top: 20px;
    padding: 10px;
    background-color: #333;
    border-radius: 5px;
}

.selected-item {
    display: inline-block;
    margin: 5px;
    padding: 5px 10px;
    background-color: #555;
    border-radius: 3px;
}

#connections-feedback {
    margin-top: 15px;
    min-height: 50px;
}

.success {
    color: #8bc34a;
}

.error {
    color: #f44336;
}

.chemical-puzzle {
    max-width: 600px;
    margin: 0 auto;
}

.compounds-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin: 20px 0;
}

.compound-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 10px;
    background: rgba(0,0,0,0.2);
    border-radius: 5px;
}

.compound-formula {
    font-size: 24px;
    margin-bottom: 10px;
    font-family: 'Courier New', monospace;
}

.compound-item input {
    width: 100%;
    padding: 5px;
    text-align: center;
    background: rgba(255,255,255,0.1);
    border: 1px solid #555;
    color: white;
}

.feedback-icon {
    margin-top: 5px;
    font-weight: bold;
}

.chemical-success {
    display: none;
    background: rgba(0,100,0,0.3);
    padding: 10px;
    border-radius: 5px;
    margin: 15px 0;
    text-align: center;
}
    </style>
</head>
<body>
    <div id="threejs-container"></div>
    
    <div id="inventory">
        <h3>Inventory</h3>
        <div id="inventory-items"></div>
    </div>
    
    <div id="ui-container">
        <div id="room-description">
            <p>Your head throbs as consciousness returns. The sterile scent of ethanol mixes with something more acrid - ozone? Burning? Your vision clears to reveal a dim laboratory, illuminated only by the flickering glow of dying fluorescent lights.</p>
            <p>The cold metal table beneath you explains the stiffness in your limbs. How long were you out? The last thing you remember is... nothing. Just darkness.</p>
            <p>A digital keypad by the reinforced door mocks you with its glowing red display: "LOCKED - ENTER 4-DIGIT CODE". The air feels thick with secrets and the weight of forgotten experiments.</p>
        </div>
    </div>

    <!-- Modal for interactions -->
    <div id="interaction-modal" class="modal">
        <div class="modal-content" id="modal-content">
            <span class="modal-close">&times;</span>
            <div id="modal-title"></div>
            <div id="modal-description"></div>
            <div id="modal-interactions"></div>
        </div>
    </div>

    <!-- Load Three.js and plugins from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>

    <script>
        // Initialize Three.js scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        
        // Enhanced lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        scene.add(directionalLight);
        
        // Camera setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 5);
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('threejs-container').appendChild(renderer.domElement);
        
        // Controls with better navigation
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1, 0);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 3;
        controls.maxDistance = 15;
        controls.maxPolarAngle = Math.PI * 0.9;

        // Room construction - only outer walls
        const roomSize = 15;
        const wallHeight = 7;
        const wallThickness = 0.5;

        // Floor with puddles and dirt
const floorTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/terrain/grass_roughness.jpg'); // Replace with concrete texture
const floorNormalMap = new THREE.TextureLoader().load('https://threejs.org/examples/textures/terrain/grass_normal.jpg'); // Replace with concrete normal map

const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(roomSize, roomSize, 100, 100),
    new THREE.MeshStandardMaterial({ 
        color: 0x3a3a3a,
        roughness: 0.9,
        metalness: 0.1,
        map: floorTexture,
        normalMap: floorNormalMap,
        normalScale: new THREE.Vector2(0.5, 0.5)
    })
);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);

// Create puddles
const createPuddles = () => {
    const puddleGeometry = new THREE.CircleGeometry(0.5, 32);
    const puddleMaterial = new THREE.MeshStandardMaterial({
        color: 0x333355,
        transparent: true,
        opacity: 0.7,
        roughness: 0.1,
        metalness: 0.8
    });
    
    for (let i = 0; i < 8; i++) {
        const puddle = new THREE.Mesh(puddleGeometry, puddleMaterial);
        puddle.rotation.x = -Math.PI / 2;
        puddle.position.set(
            (Math.random() - 0.5) * roomSize * 0.8,
            0.01, // Slightly above floor
            (Math.random() - 0.5) * roomSize * 0.8
        );
        puddle.scale.set(1 + Math.random(), 1 + Math.random(), 1);
        scene.add(puddle);
    }
};
createPuddles();

// Wall material with dirt and decay
const wallTexture = new THREE.TextureLoader().load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQ-662x6miZQUJy4ep94mw13Qv9T9gOw8162A&s'); // Replace with concrete/dirty wall texture
wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
wallTexture.repeat.set(4, 2);

const wallNormalMap = new THREE.TextureLoader().load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQ-662x6miZQUJy4ep94mw13Qv9T9gOw8162A&s'); // Replace with appropriate normal map
wallNormalMap.wrapS = wallNormalMap.wrapT = THREE.RepeatWrapping;
wallNormalMap.repeat.set(4, 2);

const wallMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x3a3a4a,
    roughness: 0.8,
    metalness: 0.1,
    map: wallTexture,
    normalMap: wallNormalMap,
    side: THREE.DoubleSide
});

// Add grime and stains to walls
const addWallDecay = (wall) => {
    // You could add decals or additional geometry here for more detail
    wall.material = wallMaterial.clone();
    wall.material.color.setHSL(0.66, 0.2, 0.3 + Math.random() * 0.1);
    
    // Random discoloration
    if (Math.random() > 0.7) {
        wall.material.color.offsetHSL(0, 0, -0.1 - Math.random() * 0.1);
    }
};

// Left wall
const leftWall = new THREE.Mesh(
    new THREE.PlaneGeometry(roomSize, wallHeight),
    wallMaterial
);
leftWall.position.set(-roomSize/2, wallHeight/2, 0);
leftWall.rotation.y = Math.PI / 2;
addWallDecay(leftWall);
scene.add(leftWall);

// Right wall
const rightWall = new THREE.Mesh(
    new THREE.PlaneGeometry(roomSize, wallHeight),
    wallMaterial
);
rightWall.position.set(roomSize/2, wallHeight/2, 0);
rightWall.rotation.y = -Math.PI / 2;
addWallDecay(rightWall);
scene.add(rightWall);

// Back wall
const backWall = new THREE.Mesh(
    new THREE.PlaneGeometry(roomSize, wallHeight),
    wallMaterial
);
backWall.position.set(0, wallHeight/2, -roomSize/2);
addWallDecay(backWall);
scene.add(backWall);

// Front wall with door opening
const frontWallLeft = new THREE.Mesh(
    new THREE.PlaneGeometry(roomSize/2 - 1, wallHeight),
    wallMaterial
);
frontWallLeft.position.set(-roomSize/4 - 0.5, wallHeight/2, roomSize/2);
addWallDecay(frontWallLeft);
scene.add(frontWallLeft);

const frontWallRight = new THREE.Mesh(
    new THREE.PlaneGeometry(roomSize/2 - 1, wallHeight),
    wallMaterial
);
frontWallRight.position.set(roomSize/4 + 0.5, wallHeight/2, roomSize/2);
addWallDecay(frontWallRight);
scene.add(frontWallRight);

// Ceiling with stains
const ceilingTexture = new THREE.TextureLoader().load('https://static.vecteezy.com/system/resources/previews/002/243/394/large_2x/old-rusty-wall-photo.jpg'); 
ceilingTexture.wrapS = ceilingTexture.wrapT = THREE.RepeatWrapping;
ceilingTexture.repeat.set(4, 4);

const ceiling = new THREE.Mesh(
    new THREE.PlaneGeometry(roomSize, roomSize),
    new THREE.MeshStandardMaterial({ 
        color: 0x2a2a3a,
        roughness: 0.9,
        metalness: 0.05,
        map: ceilingTexture
    })
);
ceiling.position.set(0, wallHeight, 0);
ceiling.rotation.x = Math.PI / 2;
scene.add(ceiling);

// ====== EVIL SCIENTIST LAB ENHANCEMENTS ======

// 1. Flickering and broken lights (ceiling)
function createFlickeringLights(roomSize, wallHeight, scene) {
    const lightPositions = [
        [-roomSize/3, wallHeight-0.1, -roomSize/3],
        [ roomSize/3, wallHeight-0.1, -roomSize/3],
        [ 0, wallHeight-0.1, roomSize/3]
    ];
    const lightObjs = [];

    lightPositions.forEach(pos => {
        const tube = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 2, 12),
            new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                emissive: 0xffffcc,
                emissiveIntensity: 1.2
            })
        );
        tube.position.set(...pos);
        tube.rotation.z = Math.PI/2;
        scene.add(tube);

        const light = new THREE.PointLight(0xfffbe0, 1, 10, 2);
        light.position.set(pos[0], pos[1] - 0.1, pos[2]);
        scene.add(light);
        lightObjs.push({ light, tube });
    });

    // Animate flickering
    function flicker() {
        lightObjs.forEach((obj, i) => {
            const base = 0.9 + Math.sin(Date.now()/170 + i*200)*0.1 + Math.random()*0.1;
            obj.light.intensity = Math.max(0, base + (Math.random()>0.8 ? -0.7 : 0));
            obj.tube.material.emissiveIntensity = obj.light.intensity;
        });
        requestAnimationFrame(flicker);
    }
    flicker();
}
createFlickeringLights(roomSize, wallHeight, scene);

// 2. Add dark stains, blood, and "handprint" decals on walls/floor
function addWallStains(roomSize, wallHeight, scene) {
    const stainMaterial = new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load('https://i.etsystatic.com/7477300/r/il/a0a0cb/1373080092/il_570xN.1373080092_czkm.jpg'), // transparent blood splatter PNG
        transparent: true,
        depthWrite: false,
        depthTest: true
    });
    for (let i = 0; i < 5; i++) {
        const stain = new THREE.Mesh(
            new THREE.PlaneGeometry(0.6 + Math.random(), 0.4 + Math.random()*0.5),
            stainMaterial
        );
        stain.position.set(
            (Math.random()-0.5)*roomSize*0.90,
            wallHeight*0.2 + Math.random()*wallHeight*0.6,
            -roomSize/2 + 0.02 + Math.random()*0.1 // slightly off the back wall
        );
        stain.rotation.y = (Math.random()-0.5)*0.3;
        stain.rotation.z = (Math.random()-0.5)*Math.PI*2;
        stain.renderOrder = 10;
        scene.add(stain);
    }
    // Bloody handprint
    const handprintMat = stainMaterial.clone();
    handprintMat.map = new THREE.TextureLoader().load('https://www.pngarts.com/files/9/Blood-Splatter-PNG-Download-Image.png');
    const handprint = new THREE.Mesh(
        new THREE.PlaneGeometry(0.4, 0.4),
        handprintMat
    );
    handprint.position.set(roomSize/2-0.06, wallHeight*0.8, (Math.random()-0.5)*roomSize*0.5);
    handprint.rotation.y = -Math.PI/2;
    handprint.renderOrder = 10;
    scene.add(handprint);
}
addWallStains(roomSize, wallHeight, scene);

// 3. Cracked glass on floor or equipment
function addCrackedGlass(scene) {
    const texture = new THREE.TextureLoader().load('https://www.textures.com/system/gallery/photos/Decals/Damage/Floor/116572/DecalsDamageFloor0022_1_350.jpg'); // PNG crack decal
    const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
    const crack = new THREE.Mesh(new THREE.PlaneGeometry(0.7, 0.7), mat);
    crack.position.set((Math.random()-0.5)*2, 0.011, (Math.random()-0.5)*2);
    crack.rotation.x = -Math.PI/2;
    crack.renderOrder = 20;
    scene.add(crack);
}
addCrackedGlass(scene);

// 4. Broken glass shards on the floor
function scatterGlassShards(scene, roomSize) {
    const shardMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xbbfaff,
        transmission: 0.7,
        roughness: 0.05,
        metalness: 0.1,
        opacity: 0.5,
        transparent: true
    });
    for (let i = 0; i < 8; i++) {
        const geom = new THREE.BoxGeometry(0.1 + Math.random()*0.2, 0.01, 0.05 + Math.random()*0.08);
        const mesh = new THREE.Mesh(geom, shardMaterial);
        mesh.position.set(
            (Math.random()-0.5)*roomSize*0.9,
            0.015,
            (Math.random()-0.5)*roomSize*0.9
        );
        mesh.rotation.y = Math.random()*Math.PI;
        mesh.rotation.x = (Math.random()-0.5)*0.2;
        scene.add(mesh);
    }
}
scatterGlassShards(scene, roomSize);

// 5. Add a toppled chair, broken and left to rot
function addToppledChair(scene, roomSize) {
    const chair = new THREE.Group();
    // Seat
    const seat = new THREE.Mesh(
        new THREE.BoxGeometry(0.7, 0.08, 0.7),
        new THREE.MeshStandardMaterial({ color: 0x353535, roughness: 0.8 })
    );
    chair.add(seat);
    seat.position.set(0, 0, 0);
    // Back
    const back = new THREE.Mesh(
        new THREE.BoxGeometry(0.7, 0.5, 0.08),
        new THREE.MeshStandardMaterial({ color: 0x252525, roughness: 0.85 })
    );
    back.position.set(0, 0.29, -0.31);
    back.rotation.x = 0.1;
    chair.add(back);
    // Legs
    for (let i=0; i<4; i++) {
        const leg = new THREE.Mesh(
            new THREE.CylinderGeometry(0.04, 0.04, 0.38, 12),
            new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.7 })
        );
        leg.position.set(
            (i<2?-0.28:0.28),
            -0.23,
            (i%2?-0.28:0.28)
        );
        chair.add(leg);
    }
    // Randomly topple
    chair.position.set(
        (Math.random()-0.5)*roomSize*0.7,
        0.18,
        (Math.random()-0.5)*roomSize*0.7
    );
    chair.rotation.y = Math.random()*Math.PI;
    chair.rotation.x = Math.PI/6 + Math.random()*0.2;
    chair.rotation.z = Math.random()*0.3;
    scene.add(chair);
}
addToppledChair(scene, roomSize);

// 6. Add a shadowy, subtle mist/fog near the floor
scene.fog = new THREE.FogExp2(0x1a1a2a, 0.06); // Or customize color and density

// 7. Add a leaking pipe dripping onto the floor (puddle area)
function addLeakingPipe(scene, wallHeight, roomSize) {
    const pipe = new THREE.Mesh(
        new THREE.CylinderGeometry(0.1, 0.1, 2, 16),
        new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8, metalness: 0.4 })
    );
    pipe.rotation.z = Math.PI/2;
    pipe.position.set(-roomSize/2+0.8, wallHeight*0.7, -1.5);
    scene.add(pipe);

    // Dripping water (sphere drops)
    const drop = new THREE.Mesh(
        new THREE.SphereGeometry(0.05, 10, 10),
        new THREE.MeshStandardMaterial({ color: 0x99ccff, roughness: 0.2, metalness: 0.1, transparent: true, opacity: 0.7 })
    );
    scene.add(drop);
    function animateDrop() {
        drop.position.set(-roomSize/2+0.8, wallHeight*0.7-1.0 + Math.abs(Math.sin(Date.now()/500))*0.8, -1.5);
        requestAnimationFrame(animateDrop);
    }
    animateDrop();
}
addLeakingPipe(scene, wallHeight, roomSize);

// 8. Add cobwebs in upper corners
function addCobwebs(scene, roomSize, wallHeight) {
    const cobwebTex = new THREE.TextureLoader().load('https://i.imgur.com/KVQbtuE.png');
    for (let i=0; i<3; i++) {
        const cobweb = new THREE.Mesh(
            new THREE.PlaneGeometry(0.7+Math.random()*0.6, 0.7+Math.random()*0.4),
            new THREE.MeshBasicMaterial({ map: cobwebTex, transparent: true, opacity: 0.7 })
        );
        // Place in a random upper corner
        const x = i%2 ? -roomSize/2+0.01 : roomSize/2-0.01;
        const z = i<2 ? roomSize/2-0.01 : -roomSize/2+0.01;
        cobweb.position.set(x, wallHeight-0.2, z);
        cobweb.rotation.y = i%2 ? Math.PI/2 : -Math.PI/2;
        cobweb.rotation.z = (Math.random()-0.5)*0.2;
        scene.add(cobweb);
    }
}
addCobwebs(scene, roomSize, wallHeight);

// 9. Add writing on the wall ("HELP", "NO ESCAPE", etc.)
function addWallWriting(scene, roomSize, wallHeight) {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.font = "bold 48px 'Creepster', Arial, sans-serif";
    ctx.fillStyle = "#AA0000";
    ctx.fillText("NO ESCAPE", 10, 60);
    ctx.strokeStyle = "#440000";
    ctx.lineWidth = 3;
    ctx.strokeText("NO ESCAPE", 10, 60);
    ctx.globalAlpha = 0.7;
    ctx.font = "italic 28px Arial";
    ctx.fillText("it watches", 45, 110);

    const tex = new THREE.CanvasTexture(canvas);
    const graffiti = new THREE.Mesh(
        new THREE.PlaneGeometry(1.8, 0.9),
        new THREE.MeshBasicMaterial({ map: tex, transparent: true })
    );
    graffiti.position.set(0, wallHeight*0.65, -roomSize/2+0.03);
    scene.add(graffiti);
}
addWallWriting(scene, roomSize, wallHeight);

// Add some hanging wires or pipes for detail
const addHangingWires = () => {
    const wireGeometry = new THREE.BufferGeometry();
    const points = [];
    for (let i = 0; i < 5; i++) {
        points.push(new THREE.Vector3(
            (Math.random() - 0.5) * roomSize * 0.8,
            wallHeight * 0.9 - Math.random() * wallHeight * 0.5,
            (Math.random() - 0.5) * roomSize * 0.8
        ));
    }
    wireGeometry.setFromPoints(points);
    
    const wireMaterial = new THREE.LineBasicMaterial({ color: 0x666666 });
    const wire = new THREE.Line(wireGeometry, wireMaterial);
    scene.add(wire);
};
addHangingWires();

        // ===== HANGING WIRES FOR ABANDONED LAB AESTHETIC =====
function createHangingWires() {
    const wireGroup = new THREE.Group();
    const wireMaterial = new THREE.MeshStandardMaterial({
        color: 0x333333,
        roughness: 0.8,
        metalness: 0.2
    });

    // Create a grid of hanging wires across the ceiling
    const wireCount = 10; // Increased number of wires
    const gridSize = Math.ceil(Math.sqrt(wireCount));
    const spacing = roomSize / (gridSize + 1);
    
    for (let i = 0; i < wireCount; i++) {
        // Calculate grid position with some randomness
        const gridX = i % gridSize;
        const gridZ = Math.floor(i / gridSize);
        
        // Position with slight randomness to avoid perfect grid
        const x = -roomSize/2 + (gridX + 0.5 + (Math.random()-0.5)*0.3) * spacing;
        const z = -roomSize/2 + (gridZ + 0.5 + (Math.random()-0.5)*0.3) * spacing;
        
        // Random wire length (longer wires, between 2-4 meters)
        const length = 2 + Math.random() * 2;
        
        // Create wire using a cylinder
        const wireGeometry = new THREE.CylinderGeometry(0.02, 0.02, length, 8);
        const wire = new THREE.Mesh(wireGeometry, wireMaterial);
        
        // Position at ceiling and let hang straight down
        wire.position.set(x, wallHeight - length/2, z);
        
        // Remove all rotation randomness - wires hang perfectly straight down
        wire.rotation.set(0, 0, 0);
        
        wire.castShadow = true;
        wireGroup.add(wire);
        
        // Add electrical box/connector at top (more detailed)
        if (Math.random() > 0.3) {
            const connector = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.05, 0.1),
                new THREE.MeshStandardMaterial({ color: 0x666666 })
            );
            connector.position.set(x, wallHeight, z);
            wireGroup.add(connector);
            
            // Add small wires coming out of connector
            for (let j = 0; j < 3; j++) {
                const smallWire = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.01, 0.01, 0.2, 6),
                    wireMaterial
                );
                smallWire.position.set(
                    x + (Math.random() - 0.5) * 0.05,
                    wallHeight - 0.1,
                    z + (Math.random() - 0.5) * 0.05
                );
                smallWire.rotation.x = Math.random() * Math.PI;
                smallWire.rotation.z = Math.random() * Math.PI;
                wireGroup.add(smallWire);
            }
        }
        
        // Add sparking effect to some wires (20% chance)
        if (Math.random() > 0.8) {
            createSparkEffect(x, wallHeight - length, z, wireGroup);
        }
    }
    
    // Remove the curved wires section completely to ensure all wires are straight
    
    return wireGroup;
}

function createSparkEffect(x, y, z, parentGroup) {
    const sparkGroup = new THREE.Group();
    sparkGroup.position.set(x, y, z);
    
    // Create small sparks
    const sparkCount = 3 + Math.floor(Math.random() * 3);
    const sparks = [];
    
    for (let i = 0; i < sparkCount; i++) {
        const spark = new THREE.Mesh(
            new THREE.SphereGeometry(0.02, 8, 8),
            new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                transparent: true,
                opacity: 0.8
            })
        );
        spark.position.set(
            (Math.random() - 0.5) * 0.1,
            (Math.random() - 0.5) * 0.1,
            (Math.random() - 0.5) * 0.1
        );
        sparks.push(spark);
        sparkGroup.add(spark);
    }
    
    // Animation for sparks
    let time = 0;
    function animateSparks() {
        time += 0.1;
        sparks.forEach((spark, i) => {
            spark.position.y = Math.sin(time * 2 + i) * 0.05;
            spark.material.opacity = 0.5 + Math.sin(time * 3 + i) * 0.3;
            spark.scale.setScalar(0.8 + Math.sin(time * 5 + i) * 0.3);
        });
        requestAnimationFrame(animateSparks);
    }
    animateSparks();
    
    parentGroup.add(sparkGroup);
}

// Add hanging wires to scene
const hangingWires = createHangingWires();
scene.add(hangingWires);

// ===== DANGEROUS EXPOSED WIRING =====
function createExposedWiring() {
    const wiringGroup = new THREE.Group();
    const wireMaterial = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        roughness: 0.7,
        metalness: 0.5,
        emissive: 0xffaa00,
        emissiveIntensity: 0.3
    });

    // Create several wiring runs along walls and ceiling
    const wiringPaths = [
        // Wall wiring
        { 
            points: [
                new THREE.Vector3(-roomSize/2 + 1, wallHeight - 1, -roomSize/2 + 1),
                new THREE.Vector3(-roomSize/2 + 1, wallHeight - 1.5, -roomSize/2 + 3),
                new THREE.Vector3(-roomSize/2 + 1, wallHeight - 2, -roomSize/2 + 5)
            ],
            broken: true
        },
        // Ceiling wiring
        {
            points: [
                new THREE.Vector3(-2, wallHeight - 0.1, 0),
                new THREE.Vector3(0, wallHeight - 0.2, 1),
                new THREE.Vector3(2, wallHeight - 0.3, 0),
                new THREE.Vector3(3, wallHeight - 0.4, -2)
            ],
            broken: false
        }
    ];

    wiringPaths.forEach(path => {
        // Create the curve path
        const curve = new THREE.CatmullRomCurve3(path.points);
        const geometry = new THREE.TubeGeometry(curve, 20, 0.03, 8, false);
        const wire = new THREE.Mesh(geometry, wireMaterial);
        wiringGroup.add(wire);

        // Add broken ends if needed
        if (path.broken) {
            const lastPoint = path.points[path.points.length - 1];
            const brokenEnd = new THREE.Mesh(
                new THREE.CylinderGeometry(0.04, 0.01, 0.2, 8),
                new THREE.MeshStandardMaterial({ color: 0x888888 })
            );
            brokenEnd.position.copy(lastPoint);
            brokenEnd.rotation.x = Math.PI/2;
            wiringGroup.add(brokenEnd);
        }
    });

    return wiringGroup;
}

const exposedWiring = createExposedWiring();
scene.add(exposedWiring);

        // Interactive objects
        const interactiveObjects = [];

        // ===== LABORATORY EQUIPMENT ADDITIONS =====

// Glass material to reuse
const glassMaterial = new THREE.MeshPhysicalMaterial({
    color: 0x88ccff,
    transmission: 0.9,
    roughness: 0.1,
    metalness: 0.0,
    clearcoat: 1.0,
    clearcoatRoughness: 0.1,
    ior: 1.5,
    thickness: 0.5,
    transparent: true,
    opacity: 0.7
});

// Metal material for equipment
const metalMaterial = new THREE.MeshStandardMaterial({
    color: 0xaaaaaa,
    roughness: 0.3,
    metalness: 0.8
});

// 1. CHEMISTRY WORKBENCH
const workbench = new THREE.Group();
workbench.position.set(-4, 0, 2);

// Bench surface
const benchSurface = new THREE.Mesh(
    new THREE.BoxGeometry(2, 0.1, 1.5),
    new THREE.MeshStandardMaterial({ 
        color: 0x333333,
        roughness: 0.7
    })
);
benchSurface.position.set(0, 0.05, 0);
benchSurface.receiveShadow = true;
workbench.add(benchSurface);

// Test tube rack
const tubeRack = new THREE.Group();
for (let i = 0; i < 6; i++) {
    const tube = new THREE.Mesh(
        new THREE.CylinderGeometry(0.08, 0.08, 0.7, 32),
        glassMaterial
    );
    tube.position.set(-0.4 + i * 0.16, 0.4, 0);
    tube.castShadow = true;
    
    // Add colored liquid
    if (i % 2 === 0) {
        const liquid = new THREE.Mesh(
            new THREE.CylinderGeometry(0.07, 0.07, 0.3, 32),
            new THREE.MeshPhysicalMaterial({
                color: [0xff0000, 0x00ff00, 0x0000ff][i % 3],
                transmission: 0.5,
                roughness: 0.2,
                emissive: [0xff0000, 0x00ff00, 0x0000ff][i % 3],
                emissiveIntensity: 0.3
            })
        );
        liquid.position.set(-0.4 + i * 0.16, 0.25, 0);
        tubeRack.add(liquid);
    }
    tubeRack.add(tube);
}
tubeRack.position.set(0, 0, -0.3);
workbench.add(tubeRack);

// Bunsen burner
const burnerBase = new THREE.Mesh(
    new THREE.CylinderGeometry(0.15, 0.15, 0.2, 32),
    metalMaterial
);
burnerBase.position.set(0.5, 0.1, 0.4);
workbench.add(burnerBase);

const burnerTube = new THREE.Mesh(
    new THREE.CylinderGeometry(0.05, 0.05, 0.3, 16),
    metalMaterial
);
burnerTube.position.set(0.5, 0.3, 0.4);
burnerTube.rotation.x = Math.PI/4;
workbench.add(burnerTube);

// Flame effect
const flame = new THREE.Mesh(
    new THREE.ConeGeometry(0.08, 0.3, 4),
    new THREE.MeshBasicMaterial({
        color: 0xff6600,
        transparent: true,
        opacity: 0.7
    })
);
flame.position.set(0.5, 0.45, 0.55);
workbench.add(flame);

// Make flame flicker
function animateFlame() {
    const scale = 0.8 + Math.random() * 0.4;
    flame.scale.set(scale, scale, scale);
    setTimeout(animateFlame, 100);
}
animateFlame();

// 2. MICROSCOPE SETUP
const microscope = new THREE.Group();
microscope.position.set(1, 0.8, -1);

// Base
const microBase = new THREE.Mesh(
    new THREE.BoxGeometry(0.4, 0.2, 0.4),
    metalMaterial
);
microBase.castShadow = true;
microscope.add(microBase);

// Arm
const arm = new THREE.Mesh(
    new THREE.CylinderGeometry(0.05, 0.05, 0.8, 16),
    metalMaterial
);
arm.position.set(0, 0.5, 0.2);
arm.rotation.x = Math.PI * 0.3;
microscope.add(arm);

// Eyepiece
const eyepiece = new THREE.Mesh(
    new THREE.SphereGeometry(0.15, 32, 16, 0, Math.PI * 2, 0, Math.PI * 0.5),
    metalMaterial
);
eyepiece.position.set(0, 0.9, 0.35);
microscope.add(eyepiece);

// Objective lens
const lens = new THREE.Mesh(
    new THREE.CylinderGeometry(0.1, 0.1, 0.05, 32),
    new THREE.MeshPhysicalMaterial({
        color: 0x000000,
        transmission: 0.9,
        roughness: 0.0,
        metalness: 0.1,
        ior: 1.5
    })
);
lens.position.set(0, 0.5, -0.1);
microscope.add(lens);

// Slide
const slide = new THREE.Mesh(
    new THREE.BoxGeometry(0.3, 0.01, 0.1),
    new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.1
    })
);
slide.position.set(0, 0.2, -0.2);
microscope.add(slide);

// 3. ERRLENMEYER FLASK WITH GLOWING LIQUID
const flask = new THREE.Group();
flask.position.set(3, 0.5, 1);

// Flask body
const flaskBody = new THREE.Mesh(
    new THREE.CylinderGeometry(0.5, 0.3, 1.2, 32),
    glassMaterial
);
flaskBody.position.y = 0.6;
flask.add(flaskBody);

// Glowing liquid
const glowingLiquid = new THREE.Mesh(
    new THREE.CylinderGeometry(0.48, 0.28, 0.8, 32),
    new THREE.MeshPhysicalMaterial({
        color: 0x00ff88,
        transmission: 0.7,
        roughness: 0.2,
        emissive: 0x00ff88,
        emissiveIntensity: 0.5
    })
);
glowingLiquid.position.y = 0.4;
flask.add(glowingLiquid);

// Bubbles
for (let i = 0; i < 10; i++) {
    const bubble = new THREE.Mesh(
        new THREE.SphereGeometry(0.05 + Math.random() * 0.03, 16, 16),
        new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            transmission: 1.0,
            roughness: 0.0,
            metalness: 0.0,
            ior: 1.33
        })
    );
    bubble.position.set(
        (Math.random() - 0.5) * 0.4,
        Math.random() * 0.7,
        (Math.random() - 0.5) * 0.4
    );
    flask.add(bubble);
}

// 4. CENTRIFUGE MACHINE
const centrifuge = new THREE.Group();
centrifuge.position.set(-2, 0.5, 3);

// Machine body
const centrifugeBody = new THREE.Mesh(
    new THREE.BoxGeometry(0.8, 0.6, 0.6),
    new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        roughness: 0.5,
        metalness: 0.7
    })
);
centrifuge.add(centrifugeBody);

// Lid
const centrifugeLid = new THREE.Mesh(
    new THREE.CylinderGeometry(0.35, 0.35, 0.05, 32),
    new THREE.MeshStandardMaterial({
        color: 0x999999,
        roughness: 0.4,
        metalness: 0.8
    })
);
centrifugeLid.position.set(0, 0.325, 0);
centrifuge.add(centrifugeLid);

// Control panel
const panel = new THREE.Mesh(
    new THREE.PlaneGeometry(0.4, 0.2),
    new THREE.MeshStandardMaterial({
        color: 0x111111,
        emissive: 0x111111,
        emissiveIntensity: 0.2
    })
);
panel.position.set(0, 0.2, 0.31);
panel.rotation.x = -Math.PI/2;
centrifuge.add(panel);

// Add buttons
for (let i = 0; i < 3; i++) {
    const button = new THREE.Mesh(
        new THREE.CylinderGeometry(0.03, 0.03, 0.02, 16),
        new THREE.MeshStandardMaterial({
            color: [0xff0000, 0xffff00, 0x00ff00][i],
            emissive: [0xff0000, 0xffff00, 0x00ff00][i],
            emissiveIntensity: 0.3
        })
    );
    button.position.set(-0.1 + i * 0.1, 0.21, 0.31);
    centrifuge.add(button);
}

// Add all equipment to scene
scene.add(workbench);
scene.add(microscope);
scene.add(flask);
scene.add(centrifuge);

// Add interaction data for new objects
workbench.userData = {
    name: "Chemistry Workbench",
    description: "A workstation with test tubes, burners, and various glassware.",
    onClick: () => showModal("Workbench", "The workbench contains various chemistry equipment. Some test tubes contain colorful liquids.", `
        <button class="interaction-button" onclick="modal.style.display='none'">Close</button>
    `)
};

microscope.userData = {
    name: "Microscope",
    description: "A high-powered microscope focused on a specimen slide.",
    onClick: () => showModal("Microscope", "Looking through the microscope reveals strange cellular structures unlike anything natural.", `
        <button class="interaction-button" onclick="modal.style.display='none'">Close</button>
    `)
};

flask.userData = {
    name: "Glowing Flask",
    description: "An Erlenmeyer flask containing a luminescent green liquid.",
    onClick: () => showModal("Mysterious Flask", "The liquid pulses gently with an inner light. It feels warm to the touch.", `
        <button class="interaction-button" onclick="modal.style.display='none'">Close</button>
    `)
};

centrifuge.userData = {
    name: "Centrifuge",
    description: "A laboratory centrifuge for separating substances.",
    onClick: () => showModal("Centrifuge", "The machine hums quietly. A label reads: 'Subject 314 samples only'.", `
        <button class="interaction-button" onclick="modal.style.display='none'">Close</button>
    `)
};

// Add to interactive objects array
interactiveObjects.push(workbench, microscope, flask, centrifuge);
        // Door (purple as you liked)
        const door = new THREE.Mesh(
            new THREE.BoxGeometry(2, 4, 0.1),
            new THREE.MeshStandardMaterial({ color: 0x8844ff })
        );
        door.position.set(0, 2, roomSize/2 - 0.05);
        door.castShadow = true;
        door.userData = {
            name: "Exit Door",
            description: "Reinforced steel door with a keypad. The only way out.",
            onClick: () => showDoorInteraction()
        };
        scene.add(door);
        interactiveObjects.push(door);

        // Keypad
        const keypad = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 0.3, 0.05),
            new THREE.MeshStandardMaterial({ color: 0x111111 })
        );
        keypad.position.set(0.8, 1.2, roomSize/2);
        scene.add(keypad);

        // Update the desk creation code to add more items
const desk = new THREE.Group();
desk.position.set(-3, 0.4, -3);

// Desk surface
const deskSurface = new THREE.Mesh(
    new THREE.BoxGeometry(3, 0.8, 1.5),
    new THREE.MeshStandardMaterial({ 
        color: 0x555555,
        roughness: 0.7
    })
);
deskSurface.castShadow = true;
deskSurface.receiveShadow = true;
desk.add(deskSurface);

// Add desk drawers
const drawerMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
for (let i = 0; i < 3; i++) {
    const drawer = new THREE.Mesh(
        new THREE.BoxGeometry(2.8, 0.2, 0.4),
        drawerMaterial
    );
    drawer.position.set(0, -0.3 + i * 0.25, 0.55);
    drawer.castShadow = true;
    desk.add(drawer);
    
    // Add drawer handle
    const handle = new THREE.Mesh(
        new THREE.CylinderGeometry(0.05, 0.05, 0.2, 16),
        new THREE.MeshStandardMaterial({ color: 0x888888 })
    );
    handle.rotation.z = Math.PI/2;
    handle.position.set(0.8, -0.3 + i * 0.25, 0.75);
    desk.add(handle);
}

// Add papers
const paperGeometry = new THREE.PlaneGeometry(0.3, 0.4);
const paperMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xffffdd,
    side: THREE.DoubleSide
});
for (let i = 0; i < 5; i++) {
    const paper = new THREE.Mesh(paperGeometry, paperMaterial);
    paper.position.set(
        -1 + Math.random() * 1.5,
        0.41,
        -0.5 + Math.random() * 0.8
    );
    paper.rotation.x = Math.PI/2;
    paper.rotation.z = (Math.random() - 0.5) * 0.5;
    paper.receiveShadow = true;
    desk.add(paper);
}

// Add a desk lamp
const lampBase = new THREE.Mesh(
    new THREE.CylinderGeometry(0.1, 0.1, 0.2, 16),
    new THREE.MeshStandardMaterial({ color: 0x333333 })
);
lampBase.position.set(1, 0.5, -0.5);
desk.add(lampBase);

const lampArm = new THREE.Mesh(
    new THREE.CylinderGeometry(0.03, 0.03, 0.8, 16),
    new THREE.MeshStandardMaterial({ color: 0x222222 })
);
lampArm.position.set(1, 0.9, -0.5);
lampArm.rotation.z = Math.PI/4;
desk.add(lampArm);

const lampShade = new THREE.Mesh(
    new THREE.ConeGeometry(0.2, 0.3, 16),
    new THREE.MeshStandardMaterial({ color: 0xaaaaaa })
);
lampShade.position.set(1.25, 1.1, -0.75);
lampShade.rotation.x = Math.PI/2;
desk.add(lampShade);

// Add a light to the lamp
const lampLight = new THREE.PointLight(0xffeedd, 1, 2);
lampLight.position.set(1.25, 1.05, -0.75);
desk.add(lampLight);

// Add a stapler
const staplerBase = new THREE.Mesh(
    new THREE.BoxGeometry(0.15, 0.05, 0.08),
    new THREE.MeshStandardMaterial({ color: 0x888888 })
);
staplerBase.position.set(-0.5, 0.41, -0.3);
desk.add(staplerBase);

const staplerTop = new THREE.Mesh(
    new THREE.BoxGeometry(0.15, 0.03, 0.08),
    new THREE.MeshStandardMaterial({ color: 0x666666 })
);
staplerTop.position.set(-0.5, 0.45, -0.3);
staplerTop.rotation.x = Math.PI/8;
desk.add(staplerTop);

// Add a coffee mug
const mug = new THREE.Mesh(
    new THREE.CylinderGeometry(0.08, 0.1, 0.12, 16),
    new THREE.MeshStandardMaterial({ color: 0x442211 })
);
mug.position.set(0.8, 0.46, 0.2);
desk.add(mug);

// Add interactive data
desk.userData = {
    name: "Lab Desk",
    description: "Cluttered with research notes and equipment.",
    onClick: () => showDeskInteraction()
};
scene.add(desk);
interactiveObjects.push(desk);

        // ===== ENHANCED CABINET =====
        const cabinet = new THREE.Group();
        cabinet.position.set(3, 1.5, -3);
        
        // Cabinet frame (wooden texture)
        const cabinetTexture = new THREE.MeshStandardMaterial({
            color: 0x5a3a2a,
            roughness: 0.7,
            metalness: 0.1
        });
        
        const cabinetFrame = new THREE.Mesh(
            new THREE.BoxGeometry(2, 3, 1),
            cabinetTexture
        );
        cabinetFrame.castShadow = true;
        cabinetFrame.receiveShadow = true;
        cabinet.add(cabinetFrame);
        
        // Drawers with handles
        const drawerPositions = [0.7, 0, -0.7];
        const drawerMaterials = [
            new THREE.MeshStandardMaterial({ color: 0x6b4b3a }), // Darker wood
            new THREE.MeshStandardMaterial({ color: 0x5a3a2a }), // Medium wood
            new THREE.MeshStandardMaterial({ color: 0x4a2a1a })  // Darkest wood
        ];

        const drawers = [];
        drawerPositions.forEach((yPos, i) => {
            const drawer = new THREE.Mesh(
                new THREE.BoxGeometry(1.8, 0.7, 0.9),
                drawerMaterials[i]
            );
            drawer.position.set(0, yPos, 0.05);
            drawer.castShadow = true;
            drawer.receiveShadow = true;
            
            // Add drawer handle
            const handleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.2, 16);
            const handleMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.rotation.z = Math.PI/2;
            handle.position.set(0.8, yPos, 0.4);
            handle.castShadow = true;
            
            drawer.userData = {
                isDrawer: true,
                drawerNumber: i+1,
                locked: i !== 0 // First drawer unlocked
            };
            
            cabinet.add(drawer);
            cabinet.add(handle);
            drawers.push(drawer);
        });

        // Add cabinet legs
        const legGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.1, 16);
        const legPositions = [
            { x: 0.9, z: 0.45 },
            { x: -0.9, z: 0.45 },
            { x: 0.9, z: -0.45 },
            { x: -0.9, z: -0.45 }
        ];
        
        legPositions.forEach(pos => {
            const leg = new THREE.Mesh(legGeometry, new THREE.MeshStandardMaterial({ color: 0x333333 }));
            leg.position.set(pos.x, -1.55, pos.z);
            leg.castShadow = true;
            cabinet.add(leg);
        });

        cabinet.userData = {
            name: "Supply Cabinet",
            description: "A sturdy wooden cabinet with three drawers.",
            onClick: () => showCabinetInteraction(),
            isCabinet: true,
            drawers: drawers
        };
        scene.add(cabinet);
        interactiveObjects.push(cabinet);
        drawers.forEach(drawer => interactiveObjects.push(drawer));

        // ===== ENHANCED BOOKSHELF =====
        const bookshelf = new THREE.Group();
        bookshelf.position.set(0, 2.5, -4);

        // Bookshelf frame
        const frameMaterial = new THREE.MeshStandardMaterial({
            color: 0x3a2a1f,
            roughness: 0.6
        });
        
        const frame = new THREE.Mesh(
            new THREE.BoxGeometry(4, 5, 0.5),
            frameMaterial
        );
        frame.castShadow = true;
        frame.receiveShadow = true;
        bookshelf.add(frame);

        // Shelves
        const shelfPositions = [1.5, 0.5, -0.5, -1.5];
        shelfPositions.forEach(yPos => {
            const shelf = new THREE.Mesh(
                new THREE.BoxGeometry(3.8, 0.1, 0.4),
                frameMaterial
            );
            shelf.position.set(0, yPos, 0);
            shelf.castShadow = true;
            shelf.receiveShadow = true;
            bookshelf.add(shelf);
        });

        // Books - different colors and sizes
        const bookColors = [
            0x8b0000, 0x006400, 0x00008b, 0x8b008b, 
            0x8b4513, 0x2f4f4f, 0x4682b4, 0x556b2f
        ];
        
        for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 8; j++) {
                const bookHeight = 0.5 + Math.random() * 0.5;
                const bookWidth = 0.2 + Math.random() * 0.1;
                const bookDepth = 0.15 + Math.random() * 0.05;
                
                const book = new THREE.Mesh(
                    new THREE.BoxGeometry(bookWidth, bookHeight, bookDepth),
                    new THREE.MeshStandardMaterial({ 
                        color: bookColors[j % bookColors.length],
                        roughness: 0.3
                    })
                );
                book.castShadow = true;
                book.receiveShadow = true;
                
                book.position.set(
                    -1.5 + j * 0.4,
                    shelfPositions[i] + bookHeight/2 + 0.05,
                    0.1
                );
                
                // Add book spine text
                const spineText = new THREE.Mesh(
                    new THREE.PlaneGeometry(bookWidth * 0.9, bookHeight * 0.8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.7
                    })
                );
                spineText.position.set(
                    book.position.x,
                    book.position.y,
                    book.position.z + bookDepth/2 + 0.01
                );
                spineText.rotation.y = Math.PI;
                
                bookshelf.add(book);
                bookshelf.add(spineText);
            }
        }

        bookshelf.userData = {
            name: "Bookshelf",
            description: "A floor-to-ceiling bookshelf filled with scientific tomes.",
            onClick: () => showBookshelfInteraction()
        };
        scene.add(bookshelf);
        interactiveObjects.push(bookshelf);

        // ===== ENHANCED COMPUTER TERMINAL =====
        const terminal = new THREE.Group();
        terminal.position.set(2, 0.4, 2);

        // Computer base
        const base = new THREE.Mesh(
            new THREE.BoxGeometry(0.8, 0.1, 0.8),
            new THREE.MeshStandardMaterial({ color: 0x222222 })
        );
        base.castShadow = true;
        base.receiveShadow = true;
        terminal.add(base);

        // Monitor
        const monitor = new THREE.Mesh(
            new THREE.BoxGeometry(0.7, 0.5, 0.02),
            new THREE.MeshStandardMaterial({ color: 0x111111 })
        );
        monitor.position.set(0, 0.35, 0.4);
        monitor.castShadow = true;
        terminal.add(monitor);

        // Monitor screen
        const screen = new THREE.Mesh(
            new THREE.PlaneGeometry(0.65, 0.45),
            new THREE.MeshStandardMaterial({ 
                color: 0x00aa00,
                emissive: 0x00aa00,
                emissiveIntensity: 0.5
            })
        );
        screen.position.set(0, 0.35, 0.41);
        terminal.add(screen);

        // Keyboard
        const keyboard = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 0.02, 0.3),
            new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        keyboard.position.set(0, 0.1, 0.1);
        keyboard.castShadow = true;
        terminal.add(keyboard);

        // Add some keyboard keys
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 10; j++) {
                const key = new THREE.Mesh(
                    new THREE.BoxGeometry(0.05, 0.02, 0.05),
                    new THREE.MeshStandardMaterial({ color: 0x555555 })
                );
                key.position.set(
                    -0.25 + j * 0.055,
                    0.11,
                    0.1 - i * 0.1
                );
                key.castShadow = true;
                terminal.add(key);
            }
        }

        terminal.userData = {
            name: "Computer Terminal",
            description: "An old CRT computer terminal with green monochrome display.",
            onClick: () => showComputerInteraction()
        };
        scene.add(terminal);
        interactiveObjects.push(terminal);

        // ===== ENHANCED PERIODIC TABLE =====
        const chart = new THREE.Group();
        chart.position.set(4, 1.5, 0);
        chart.rotation.y = -Math.PI/2;

        // Chart background
        const background = new THREE.Mesh(
            new THREE.PlaneGeometry(2, 1.5),
            new THREE.MeshStandardMaterial({ color: 0x88aaff })
        );
        background.receiveShadow = true;
        chart.add(background);

        // Create periodic table grid
        const gridMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
        const gridGeometry = new THREE.BufferGeometry();
        
        // Vertical lines
        const positions = [];
        for (let x = -0.9; x <= 0.9; x += 0.2) {
            positions.push(x, -0.75, 0.01, x, 0.75, 0.01);
        }
        
        // Horizontal lines
        for (let y = -0.75; y <= 0.75; y += 0.25) {
            positions.push(-0.9, y, 0.01, 0.9, y, 0.01);
        }
        
        gridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        
        const grid = new THREE.LineSegments(gridGeometry, gridMaterial);
        chart.add(grid);

        // Add element boxes with "POSSESS" highlighted
        const elements = [
            { symbol: "H", x: -0.8, y: 0.5 },
            { symbol: "He", x: 0.8, y: 0.5 },
            // ... more elements would go here
            { symbol: "P", x: -0.6, y: -0.5, highlight: true },
            { symbol: "O", x: -0.4, y: -0.5, highlight: true },
            { symbol: "S", x: -0.2, y: -0.5, highlight: true },
            { symbol: "S", x: 0, y: -0.5, highlight: true },
            { symbol: "E", x: 0.2, y: -0.5, highlight: true },
            { symbol: "S", x: 0.4, y: -0.5, highlight: true }
        ];
        
        elements.forEach(el => {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            context.fillStyle = el.highlight ? '#ff0000' : '#ffffff';
            context.fillRect(0, 0, 64, 64);
            context.font = '24px Arial';
            context.fillStyle = '#000000';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(el.symbol, 32, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const element = new THREE.Mesh(
                new THREE.PlaneGeometry(0.15, 0.15),
                new THREE.MeshStandardMaterial({ map: texture })
            );
            element.position.set(el.x, el.y, 0.02);
            chart.add(element);
        });

        chart.userData = {
    name: "Chemical Chart",
    description: "A periodic table with certain elements highlighted to spell 'POSSESS'.",
    onClick: () => showChemicalPuzzle()
};
        scene.add(chart);
        interactiveObjects.push(chart);

        // Whiteboard (updated version)
const whiteboard = new THREE.Mesh(
    new THREE.PlaneGeometry(2.5, 1.8),
    new THREE.MeshStandardMaterial({ 
        color: 0xffffff,
        roughness: 0.4,
        metalness: 0.1
    })
);
whiteboard.position.set(-4.9, 1.8, 0); // Positioned on left wall
whiteboard.rotation.y = Math.PI/2; // Rotated to face into the room
whiteboard.receiveShadow = true;

// Add whiteboard frame
const whiteboardFrame = new THREE.Mesh(
    new THREE.BoxGeometry(2.6, 1.9, 0.1),
    new THREE.MeshStandardMaterial({ color: 0x333333 })
);
whiteboardFrame.position.set(-4.95, 1.8, 0);
scene.add(whiteboardFrame);

// Add some writing to the whiteboard
const canvas = document.createElement('canvas');
canvas.width = 1024;
canvas.height = 768;
const ctx = canvas.getContext('2d');
ctx.fillStyle = '#ffffff';
ctx.fillRect(0, 0, canvas.width, canvas.height);
ctx.font = "30px Arial";
ctx.fillStyle = "#000000";
ctx.fillText("Subject 314 Results:", 50, 50);
ctx.fillText("- Phase 1: Stable", 70, 100);
ctx.fillText("- Phase 2: Regeneration", 70, 150);
ctx.fillText("- Phase 3: Deterioration", 70, 200);
ctx.fillText("Time to collapse: 314min", 70, 250);
ctx.fillText("Emergency code: 314 x 2.5", 70, 300);

const whiteboardTexture = new THREE.CanvasTexture(canvas);
whiteboard.material.map = whiteboardTexture;

whiteboard.userData = {
    name: "Whiteboard",
    description: "Contains research notes about Subject 314.",
    onClick: () => showWhiteboardInteraction()
};
scene.add(whiteboard);
interactiveObjects.push(whiteboard);

        // Safe (hidden behind books)
        const safe = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 0.5, 0.1),
            new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        safe.position.set(0, 1.5, -4.5);
        safe.visible = false;
        safe.userData = {
            name: "Hidden Safe",
            description: "A secure safe hidden behind the bookshelf.",
            onClick: () => showSafeInteraction()
        };
        scene.add(safe);
        interactiveObjects.push(safe);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Game state
        const gameState = {
            inventory: [],
            discoveredClues: [],
            puzzlesSolved: 0,
            doorCode: Math.floor(1000 + Math.random() * 9000).toString(),
            storyProgress: 0,
            usedItems: [],
            endingsDiscovered: [],
            connectionsSolved: false, // Add this flag
            connectionsGameData: {
            categories: [
        {
            name: "Celestial Bodies",
            items: ["Moon", "Sun", "Star", "Comet"],
            color: "blue"
        },
        {
            name: "Laboratory Equipment",
            items: ["Beaker", "Flask", "Vial", "Tube"],
            color: "yellow"
        },
        {
            name: "Chemical Elements",
            items: ["Gold", "Iron", "Lead", "Copper"],
            color: "green"
        },
        {
            name: "Scientific Terms",
            items: ["Atom", "Gene", "Cell", "Mole"],
            color: "purple"
        }
    ],
    // Shuffled items will be stored here when game starts
    shuffledItems: []
    }
};


        // Modal functionality
        const modal = document.getElementById('interaction-modal');
        const modalContent = document.getElementById('modal-content');
        const modalTitle = document.getElementById('modal-title');
        const modalDescription = document.getElementById('modal-description');
        const modalInteractions = document.getElementById('modal-interactions');
        const modalClose = document.querySelector('.modal-close');
        


        function showModal(title, description, interactions) {
            modalTitle.innerHTML = `<h2>${title}</h2>`;
            modalDescription.innerHTML = `<p>${description}</p>`;
            modalInteractions.innerHTML = interactions;
            modal.style.display = 'flex';
        }

        modalClose.onclick = function(e) {
            e.stopPropagation();
            modal.style.display = 'none';
        }

        // Prevent clicks on modal from reaching the scene
        modalContent.addEventListener('click', function(e) {
            e.stopPropagation();
        });

        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = 'none';
            }
        }

        function checkAllCompoundsSolved() {
    const allSolved = Array.from(document.querySelectorAll('.compound-item input'))
        .every(input => input.disabled);
    
    if (allSolved) {
        const successDiv = document.getElementById('chemical-success');
        successDiv.style.display = 'block';
        addClue('chemical-puzzle-solved');
    }
}

window.checkCompoundAnswer = function(inputElement) {
    const index = inputElement.id.split('-')[1];
    const feedbackIcon = document.getElementById(`feedback-${index}`);
    const userAnswer = inputElement.value.toLowerCase().trim();
    const correctAnswer = inputElement.dataset.answer.toLowerCase();
    
    if (userAnswer === correctAnswer) {
        inputElement.disabled = true;
        feedbackIcon.innerHTML = '✓';
        feedbackIcon.style.color = '#4CAF50';
        checkAllCompoundsSolved();
    } else if (userAnswer) {
        feedbackIcon.innerHTML = '✗';
        feedbackIcon.style.color = '#F44336';
    } else {
        feedbackIcon.innerHTML = '';
    }
};

function showChemicalPuzzle() {
    // Chemical compounds and their names
    const compounds = [
        { formula: "H₂O", name: "water" },
        { formula: "CO₂", name: "carbon dioxide" },
        { formula: "NaCl", name: "sodium chloride" },
        { formula: "C₆H₁₂O₆", name: "glucose" },
        { formula: "CH₄", name: "methane" },
        { formula: "NH₃", name: "ammonia" },
        { formula: "H₂SO₄", name: "sulfuric acid" },
        { formula: "NaOH", name: "sodium hydroxide" }
    ];

    // Shuffle the compounds
    const shuffledCompounds = [...compounds].sort(() => Math.random() - 0.5);

    // Create the puzzle HTML
    let puzzleHTML = `
        <div class="chemical-puzzle">
            <h3>Name These Chemical Compounds</h3>
            <p>Identify all 8 common chemical compounds to reveal the second digit of the door code.</p>
            <div class="compounds-grid">
    `;

    // Add the compound inputs
    shuffledCompounds.forEach((compound, index) => {
        puzzleHTML += `
            <div class="compound-item">
                <div class="compound-formula">${compound.formula}</div>
                <input type="text" id="compound-${index}" data-answer="${compound.name}" 
                    placeholder="Enter name..." oninput="checkCompoundAnswer(this)">
                <span class="feedback-icon" id="feedback-${index}"></span>
            </div>
        `;
    });

    puzzleHTML += `
            </div>
            <div id="chemical-success" class="chemical-success">
                Puzzle solved! The second digit of the door code is: ${gameState.doorCode[1]}★
            </div>
            <button class="interaction-button" onclick="modal.style.display='none'">Close</button>
        </div>
    `;

    showModal("Chemical Compounds Puzzle", puzzleHTML, '');
}

        // Update inventory display
        function updateInventory() {
            const inventoryContainer = document.getElementById('inventory-items');
            inventoryContainer.innerHTML = '';
            
            gameState.inventory.forEach(item => {
                const itemElement = document.createElement('div');
                itemElement.className = 'inventory-item';
                itemElement.textContent = item.replace('-', ' ');
                inventoryContainer.appendChild(itemElement);
            });
        }

        // Add item to inventory
        function addToInventory(itemId) {
            if (!gameState.inventory.includes(itemId)) {
                gameState.inventory.push(itemId);
                updateInventory();
            }
        }

        // Add discovered clue
        function addClue(clueId) {
            if (!gameState.discoveredClues.includes(clueId)) {
                gameState.discoveredClues.push(clueId);
                gameState.puzzlesSolved++;
                updateStory();
            }
        }

        // Update story based on progress
        function updateStory() {
            const roomDesc = document.getElementById('room-description');
            
            let baseDescription = `
                <p>Your head throbs as consciousness returns. The sterile scent of ethanol mixes with something more acrid - ozone? Burning? Your vision clears to reveal a dim laboratory, illuminated only by the flickering glow of dying fluorescent lights.</p>
                <p>The cold metal table beneath you explains the stiffness in your limbs. How long were you out? The last thing you remember is... nothing. Just darkness.</p>
                <p>A digital keypad by the reinforced door mocks you with its glowing red display: "LOCKED - ENTER 4-DIGIT CODE". The air feels thick with secrets and the weight of forgotten experiments.</p>
            `;
            
            let additionalText = '';
            
            if (gameState.puzzlesSolved >= 3) {
                additionalText = `
                    <div class="story-reveal">
                        <p>As you explore, you notice references to "Project Phoenix" and "Subject 314". What kind of experiments were conducted here?</p>
                    </div>
                `;
            }
            
            roomDesc.innerHTML = baseDescription + additionalText;
        }

        // Object interaction functions
        function showDoorInteraction() {
            const interactions = `
                <div class="interaction-buttons">
                    <button class="interaction-button" onclick="showDoorCodeInput(event)">Examine Keypad</button>

                    <button class="interaction-button" onclick="showDoorNote(event)">Search Around Door</button>
                </div>
            `;
            showModal("Exit Door", "The reinforced door is your only way out. A keypad demands a 4-digit code.", interactions);
        }


        function showDoorNote(e) {
            if (e) e.stopPropagation();
            if (!gameState.inventory.includes('door-note')) {
                addToInventory('door-note');
                addClue('door-note-found');
                
                const noteContent = `
                    <p>You find a hidden note near the door frame:</p>
                    <p style="font-style: italic; background: #333; padding: 10px; border-left: 3px solid #8bc34a;">
                        "Emergency code: Subject number (314) multiplied by catalyst constant (2.5, round down)"
                    </p>
                    <p>The numbers 314 appear frequently in the lab's notes.</p>
                `;
                
                showModal("Hidden Note Found", noteContent, `<button class="interaction-button" onclick="showDoorInteraction(event)">Back to Door</button>`);
            } else {
                showModal("Exit Door", "You've already found the hidden note near the door.", `<button class="interaction-button" onclick="showDoorInteraction(event)">Back to Door</button>`);
            }
        }

        function showDoorCodeInput(e) {
            if (e) e.stopPropagation();
            let hint = '';
            if (gameState.inventory.includes('door-note')) {
                hint = `<p class="hint">The note says: 314 × 2.5 = 785 → ${gameState.doorCode}</p>`;
            } else {
                hint = '<p class="hint">Look for clues around the lab to find the code.</p>';
            }
            
            const keypadHTML = `
                <div class="keypad">
                    <div class="keypad-display" id="code-display">____</div>
                    <button onclick="addCodeDigit('1', event)">1</button>
                    <button onclick="addCodeDigit('2', event)">2</button>
                    <button onclick="addCodeDigit('3', event)">3</button>
                    <button onclick="addCodeDigit('4', event)">4</button>
                    <button onclick="addCodeDigit('5', event)">5</button>
                    <button onclick="addCodeDigit('6', event)">6</button>
                    <button onclick="addCodeDigit('7', event)">7</button>
                    <button onclick="addCodeDigit('8', event)">8</button>
                    <button onclick="addCodeDigit('9', event)">9</button>
                    <button onclick="addCodeDigit('0', event)">0</button>
                    <button onclick="clearCode(event)">C</button>
                    <button onclick="clearCode(event)">CLEAR</button>
                    <button onclick="submitCode(event)">ENTER</button>
                </div>
                ${hint}
            `;
            
            showModal("Door Keypad", "Enter the 4-digit code to escape:", keypadHTML);
        }

        let currentCode = '';
        window.addCodeDigit = function(digit, e) {
            if (e) e.stopPropagation();
            if (currentCode.length < 4) {
                currentCode += digit;
                document.getElementById('code-display').textContent = 
                    currentCode.padEnd(4, '_').split('').join(' ');
            }
        }

        window.clearCode = function(e) {
            if (e) e.stopPropagation();
            currentCode = '';
            document.getElementById('code-display').textContent = '____';
        }

        window.submitCode = function(e) {
            if (e) e.stopPropagation();
            if (currentCode === gameState.doorCode) {
                document.getElementById('code-display').className = 'keypad-display success';
                document.getElementById('code-display').textContent = 'OPEN';
                
                setTimeout(() => {
                    showModal("Escaped!", `
                        <p>The door unlocks with a satisfying clunk. You've escaped!</p>
                        <p>As you leave, you glance back at the lab, its mysteries still unsolved...</p>
                    `, `<button class="interaction-button" onclick="location.reload()">Play Again</button>`);
                    
                    // Animate door opening
                    let angle = 0;
                    const maxAngle = Math.PI / 2;
                    function animateDoor() {
                        if (angle < maxAngle) {
                            angle += 0.01;
                            door.rotation.y = -angle;
                            requestAnimationFrame(animateDoor);
                        }
                    }
                    animateDoor();
                }, 1000);
            } else {
                document.getElementById('code-display').className = 'keypad-display error';
                document.getElementById('code-display').textContent = 'ERR';
                setTimeout(() => {
                    document.getElementById('code-display').className = 'keypad-display';
                    clearCode();
                }, 1000);
            }
        }

        function showConnectionsGame() {
    // Shuffle the items if not already done
    if (gameState.connectionsGameData.shuffledItems.length === 0) {
        const allItems = [];
        gameState.connectionsGameData.categories.forEach(category => {
            category.items.forEach(item => allItems.push(item));
        });
        gameState.connectionsGameData.shuffledItems = shuffleArray([...allItems]);
    }

    // Create the game HTML
    let gameHTML = `
        <div class="connections-game">
            <h3>Make 4 groups of 4 connected items</h3>
            <div class="connections-grid">
    `;

    // Add the cards
    gameState.connectionsGameData.shuffledItems.forEach((item, index) => {
        gameHTML += `
            <div class="connections-card" data-item="${item}" onclick="selectConnectionCard(this, '${item}')">
                ${item}
            </div>
        `;
    });

    gameHTML += `
            </div>
            <div class="connections-selected">
                <h4>Selected: <span id="connections-selected-count">0</span>/4</h4>
                <div id="connections-selected-items"></div>
                <button class="interaction-button" onclick="submitConnectionSelection()" disabled id="connections-submit">Submit Group</button>
            </div>
            <div id="connections-feedback"></div>
        </div>
    `;

    showModal("Connections Puzzle", `
        <p>You found a set of cards with various words. Group them into 4 categories of 4 related items.</p>
        ${gameHTML}
    `, `<button class="interaction-button" onclick="showCabinetInteraction(event)">Back to Cabinet</button>`);
}

// Add these helper functions for the connections game
window.selectConnectionCard = function(cardElement, item) {
    const selectedCount = document.getElementById('connections-selected-count');
    const selectedItemsDiv = document.getElementById('connections-selected-items');
    const submitButton = document.getElementById('connections-submit');
    
    // Toggle selection
    if (cardElement.classList.contains('selected')) {
        cardElement.classList.remove('selected');
        // Remove from selected items
        const itemElements = selectedItemsDiv.querySelectorAll('.selected-item');
        itemElements.forEach(el => {
            if (el.textContent === item) {
                el.remove();
            }
        });
    } else {
        // Check if we can select more (max 4)
        if (selectedItemsDiv.querySelectorAll('.selected-item').length >= 4) {
            return;
        }
        cardElement.classList.add('selected');
        // Add to selected items
        const itemEl = document.createElement('span');
        itemEl.className = 'selected-item';
        itemEl.textContent = item;
        selectedItemsDiv.appendChild(itemEl);
    }
    
    // Update count and enable/disable submit button
    const selectedCountNum = selectedItemsDiv.querySelectorAll('.selected-item').length;
    selectedCount.textContent = selectedCountNum;
    submitButton.disabled = selectedCountNum !== 4;
};

window.submitConnectionSelection = function() {
    const selectedItemsDiv = document.getElementById('connections-selected-items');
    const selectedItems = Array.from(selectedItemsDiv.querySelectorAll('.selected-item')).map(el => el.textContent);
    const feedbackDiv = document.getElementById('connections-feedback');
    
    // Find which category these items belong to
    let foundCategory = null;
    for (const category of gameState.connectionsGameData.categories) {
        const allPresent = category.items.every(item => selectedItems.includes(item));
        if (allPresent) {
            foundCategory = category;
            break;
        }
    }
    
    if (foundCategory) {
        // Correct category
        feedbackDiv.innerHTML = `<p class="success">Correct! Category: ${foundCategory.name}</p>`;
        
        // Remove these items from the game
        gameState.connectionsGameData.shuffledItems = gameState.connectionsGameData.shuffledItems.filter(
            item => !selectedItems.includes(item)
        );
        
        // Mark category as solved
        foundCategory.solved = true;
        
        // Clear selection
        document.querySelectorAll('.connections-card.selected').forEach(card => {
            card.classList.remove('selected');
            card.style.display = 'none'; // Hide solved cards
        });
        selectedItemsDiv.innerHTML = '';
        document.getElementById('connections-selected-count').textContent = '0';
        document.getElementById('connections-submit').disabled = true;
        
        // Check if game is complete
        const unsolvedCategories = gameState.connectionsGameData.categories.filter(cat => !cat.solved);
        if (unsolvedCategories.length === 0) {
            // Game solved!
            setTimeout(() => {
                gameState.connectionsSolved = true;
                showModal("Connections Solved!", `
                    <p>You've successfully grouped all the cards!</p>
                    <p>The first digit of the door code is revealed: ${gameState.doorCode[0]}☽</p>
                    <p class="story-reveal">The moon symbol reminds you of the lunar phases mentioned in the desk note.</p>
                `, `<button class="interaction-button" onclick="showCabinetInteraction(event)">Back to Cabinet</button>`);
            }, 1000);
        }
    } else {
        // Incorrect grouping
        feedbackDiv.innerHTML = '<p class="error">These items do not belong to the same category. Try again.</p>';
        
        // Clear selection but keep cards visible
        document.querySelectorAll('.connections-card.selected').forEach(card => {
            card.classList.remove('selected');
        });
        selectedItemsDiv.innerHTML = '';
        document.getElementById('connections-selected-count').textContent = '0';
        document.getElementById('connections-submit').disabled = true;
    }
};
        function showDeskInteraction() {
            const interactions = `
                <div class="interaction-buttons">
                    <button class="interaction-button" onclick="searchDesk(event)">Search the Desk</button>
                </div>
            `;
            showModal("Lab Desk", "A stainless steel desk littered with research notes and equipment.", interactions);
        }

        function searchDesk(e) {
            if (e) e.stopPropagation();
            if (!gameState.inventory.includes('small-key')) {
                addToInventory('small-key');
                addClue('desk-searched');
                
                const result = `
                    <p>Under a stack of papers, you find a small brass key and a note with symbols: ☽, ★, ♞, ☀️</p>
                    <p class="story-reveal">The note reads: 'The transformation sequence must follow lunar phases.'</p>
                `;
                
                showModal("Desk Search Results", result, `<button class="interaction-button" onclick="showDeskInteraction(event)">Back to Desk</button>`);
            } else {
                showModal("Lab Desk", "You've already searched the desk thoroughly.", `<button class="interaction-button" onclick="showDeskInteraction(event)">Back to Desk</button>`);
            }
        }

        function showCabinetInteraction() {
            const interactions = `
                <div class="interaction-buttons">
                    <button class="interaction-button" onclick="openCabinetDrawer(1, event)">Open Top Drawer</button>
                    <button class="interaction-button" ${gameState.inventory.includes('small-key') ? '' : 'disabled'} 
                        onclick="openCabinetDrawer(2, event)">Open Middle Drawer</button>
                    <button class="interaction-button" ${gameState.inventory.includes('small-key') ? '' : 'disabled'} 
                        onclick="openCabinetDrawer(3, event)">Open Bottom Drawer</button>
                </div>
            `;
            showModal("Supply Cabinet", "A heavy steel cabinet with three drawers. Some are locked.", interactions);
        }

        function openCabinetDrawer(drawerNumber, e) {
    if (e) e.stopPropagation();
    
    const cabinetObj = interactiveObjects.find(obj => obj.userData.isCabinet);
    if (!cabinetObj) return;
    
    const drawer = cabinetObj.userData.drawers[drawerNumber - 1];
    if (!drawer) return;
    
    if (drawer.userData.locked) {
        if (drawerNumber === 1 || gameState.inventory.includes('small-key')) {
            // Unlock the drawer
            drawer.userData.locked = false;
            
            if (drawerNumber === 1) {
                // Top drawer - contains the connections game cards
                const result = `
                    <p>You open the top drawer and find 16 cards with various words printed on them.</p>
                    <p class="story-reveal">A note says: "Group these into 4 categories to reveal the first digit of the code."</p>
                `;
                
                // Animate drawer opening
                gsap.to(drawer.position, {
                    z: 0.5,
                    duration: 0.5,
                    onComplete: () => {
                        showModal("Cabinet Contents", result, `
                            <button class="interaction-button" onclick="showConnectionsGame(event)">Examine Cards</button>
                            <button class="interaction-button" onclick="showCabinetInteraction(event)">Back to Cabinet</button>
                        `);
                    }
                });
            } else if (drawerNumber === 2 && !gameState.inventory.includes('usb-drive')) {
                // Middle drawer - USB drive (existing code)
                addToInventory('usb-drive');
                gameState.usedItems.push('small-key');
                addClue('cabinet-opened');
                
                const result = `
                    <p>You unlock and open drawer ${drawerNumber}. Inside is a USB drive labeled "Project Phoenix".</p>
                    <p class="story-reveal">A note with the USB reads: 'Emergency override code: ${gameState.doorCode}'</p>
                `;
                
                // Animate drawer opening
                gsap.to(drawer.position, {
                    z: 0.5,
                    duration: 0.5,
                    onComplete: () => {
                        showModal("Cabinet Contents", result, `
                            <button class="interaction-button" onclick="showCabinetInteraction(event)">Back to Cabinet</button>
                        `);
                    }
                });
            } else {
                showModal("Cabinet Drawer", `Drawer ${drawerNumber} is empty.`, `
                    <button class="interaction-button" onclick="showCabinetInteraction(event)">Back to Cabinet</button>
                `);
            }
        } else {
            showModal("Locked Drawer", `Drawer ${drawerNumber} is locked. You need a key to open it.`, `
                <button class="interaction-button" onclick="showCabinetInteraction(event)">Back to Cabinet</button>
            `);
        }
    } else {
        // Drawer is already unlocked
        if (drawerNumber === 1) {
            // Top drawer - connections game
            showModal("Cabinet Drawer", "The top drawer contains the set of word cards.", `
                <button class="interaction-button" onclick="showConnectionsGame(event)">Examine Cards</button>
                <button class="interaction-button" onclick="showCabinetInteraction(event)">Back to Cabinet</button>
            `);
        } else if (drawerNumber === 2 && !gameState.inventory.includes('usb-drive')) {
            // Middle drawer - USB drive (existing code)
            addToInventory('usb-drive');
            const result = `
                <p>The drawer contains a USB drive labeled "Project Phoenix".</p>
                <p class="story-reveal">A note with the USB reads: 'Emergency override code: ${gameState.doorCode}'</p>
            `;
            showModal("Cabinet Contents", result, `
                <button class="interaction-button" onclick="showCabinetInteraction(event)">Back to Cabinet</button>
            `);
        } else {
            showModal("Cabinet Drawer", `Drawer ${drawerNumber} is empty.`, `
                <button class="interaction-button" onclick="showCabinetInteraction(event)">Back to Cabinet</button>
            `);
        }
    }
}


        function showBookshelfInteraction() {
            const interactions = `
                <div class="interaction-buttons">
                    <button class="interaction-button" onclick="browseBooks(event)">Browse Books</button>
                    <button class="interaction-button" onclick="checkBehindBooks(event)">Check Behind Books</button>
                </div>
            `;
            showModal("Bookshelf", "A collection of scientific tomes, some looking well-used.", interactions);
        }

        function browseBooks(e) {
            if (e) e.stopPropagation();
            addClue('books-browsed');
            
            const result = `
                <p>You find a cryptography book with a marked passage about celestial symbols and sequences.</p>
                <p class="story-reveal">The margin notes mention 'the sequence must be followed precisely'.</p>
            `;
            
            showModal("Cryptography Book", result, `<button class="interaction-button" onclick="showBookshelfInteraction(event)">Back to Bookshelf</button>`);
        }

        function checkBehindBooks(e) {
            if (e) e.stopPropagation();
            addClue('safe-discovered');
            
            // Make the safe visible
            safe.visible = true;
            
            const result = `
                <p>Shifting volumes reveals a wall safe with an unusual keypad - it displays scrambled letters instead of numbers.</p>
                <p>A small label reads: "Subject 314 holds the key".</p>
            `;
            
            showModal("Hidden Safe", result, `
                <button class="interaction-button" onclick="showSafeInteraction(event)">Examine Safe</button>
                <button class="interaction-button" onclick="showBookshelfInteraction(event)">Back to Bookshelf</button>
            `);
        }

        function showSafeInteraction(e) {
            if (e) e.stopPropagation();
            
            if (gameState.inventory.includes('subject-note')) {
                showAnagramPuzzle();
            } else {
                showModal("Letter Combination Safe", `
                    <p>The safe has 12 buttons displaying scrambled letters.</p>
                    <p>A small screen above shows: "Enter the hidden message from Subject 314".</p>
                    <p class="hint">You might need to find a clue about Subject 314 first.</p>
                `, `
                    <button class="interaction-button" onclick="modal.style.display='none'">Close</button>
                `);
            }
        }

        function showAnagramPuzzle() {
            const letters = "THEPOISONVESSELS".split('');
            const scrambledLetters = shuffleArray([...letters]).join(' ');
            
            showModal("Letter Combination Safe", `
                <p>Rearrange these letters to form the correct phrase:</p>
                <div class="anagram-letters">${scrambledLetters}</div>
                <p>Your note says: "Subject 314: le poisson steve"</p>
                <input type="text" id="anagram-input" size="20">
                <button class="interaction-button" onclick="checkAnagramSolution(event)">Submit</button>
                <div id="anagram-feedback"></div>
            `, `
                <button class="interaction-button" onclick="showSafeInteraction(event)">Back to Safe</button>
            `);
        }

        function checkAnagramSolution(e) {
            if (e) e.stopPropagation();
            const input = document.getElementById('anagram-input').value.toUpperCase().replace(/\s/g, '');
            const feedback = document.getElementById('anagram-feedback');
            
            if (input === "THEPOISONVESSELS") {
                feedback.innerHTML = '<p class="success">Correct! The safe opens with a hiss. Inside rests a USB drive labeled "Project Phoenix - Final Notes".</p>';
                addToInventory('usb-drive');
                addClue('safe-combination');
                safe.visible = false; // Hide the safe after opening
                addStoryReveal("A faint scent of lavender wafts from the safe's interior - the same smell you noticed when first waking up.");
            } else {
                feedback.innerHTML = '<p class="error">Incorrect! The safe beeps angrily. Try again.</p>';
            }
        }

        // Helper function to shuffle array
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function showComputerInteraction() {
    const interactions = `
        <div class="interaction-buttons">
            <button class="interaction-button" onclick="turnOnComputer(event)">Turn On Computer</button>
            ${gameState.inventory.includes('usb-drive') ? 
                `<button class="interaction-button" onclick="insertUSB(event)">Insert USB Drive</button>` : ''}
        </div>
    `;
    showModal("Computer Terminal", "An old computer terminal with a glowing screen.", interactions);
}

        function turnOnComputer(e) {
    if (e) e.stopPropagation();
    addClue('computer-on');
    
    const result = `
        <p>The computer displays a login screen with username "DR.ALCHEM" already entered.</p>
        <p class="hint">The sticky note on the keyboard says: "Remember - password changes every full moon!"</p>
        ${gameState.inventory.includes('usb-drive') ? 
            '<p>A USB port is available on the side of the computer.</p>' : 
            '<p class="hint">You notice a USB port on the side of the computer - maybe you need something to insert?</p>'}
    `;
    
    showModal("Computer Login", result, `
        ${gameState.inventory.includes('usb-drive') ? 
            `<button class="interaction-button" onclick="insertUSB(event)">Insert USB Drive</button>` : ''}
        <button class="interaction-button" onclick="showComputerInteraction(event)">Back to Computer</button>
    `);
}

        // Crossword puzzle data
        const crosswordData = {
            solution: [
                ['S', 'E', 'R', 'U', 'M'],
                ['V', 'I', 'A', 'L', 'S'],
                ['D', 'N', 'A', 'T', 'E'],
                ['G', 'E', 'N', 'E', 'S'],
                ['M', 'O', 'L', 'E', 'C']
            ],
            across: {
                1: { clue: "Experimental liquid given to subjects", row: 0, col: 0, length: 5 },
                4: { clue: "Genetic material (abbr.)", row: 2, col: 0, length: 3 },
                5: { clue: "Units of heredity", row: 3, col: 0, length: 5 },
                6: { clue: "____ule (smallest unit of a compound)", row: 4, col: 0, length: 4 }
            },
            down: {
                1: { clue: "Glass containers for chemicals", row: 0, col: 1, length: 5 },
                2: { clue: "RNA's counterpart", row: 0, col: 2, length: 3 },
                3: { clue: "PH scale measures this", row: 0, col: 4, length: 3 }
            }
        };

        function showCrosswordPuzzle(e, withHints = false) {
            if (e) e.stopPropagation();
            
            // Build the crossword grid
            let gridHTML = '<div class="crossword-container">';
            gridHTML += '<h3>Laboratory Crossword</h3>';
            gridHTML += '<p>Solve the puzzle to reveal the password</p>';
            
            // Create the grid
            gridHTML += '<div class="crossword-grid">';
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 5; col++) {
                    const cellId = `cell-${row}-${col}`;
                    const cellValue = withHints && (row === 0 || col === 0) ? crosswordData.solution[row][col] : '';
                    const isLocked = withHints && (row === 0 || col === 0);
                    
                    // Add clue numbers
                    let clueNumber = '';
                    if ((row === 0 && col === 0) || (row === 0 && col === 1) || 
                        (row === 0 && col === 2) || (row === 0 && col === 4) ||
                        (row === 2 && col === 0) || (row === 3 && col === 0) ||
                        (row === 4 && col === 0)) {
                        const acrossClue = Object.entries(crosswordData.across).find(([num, data]) => 
                            data.row === row && data.col === col);
                        const downClue = Object.entries(crosswordData.down).find(([num, data]) => 
                            data.row === row && data.col === col);
                        
                        if (acrossClue) clueNumber = acrossClue[0];
                        else if (downClue) clueNumber = downClue[0];
                    }
                    
                    gridHTML += `
                        <div class="crossword-cell">
                            ${clueNumber ? `<span class="clue-number">${clueNumber}</span>` : ''}
                            <input type="text" maxlength="1" id="${cellId}" 
                                   value="${cellValue}" 
                                   ${isLocked ? 'readonly style="color:#8bc34a;"' : ''}
                                   oninput="this.value = this.value.toUpperCase(); checkCrosswordCompletion()">
                        </div>
                    `;
                }
            }
            gridHTML += '</div>';
            
            // Add clues
            gridHTML += '<div class="crossword-clues">';
            gridHTML += '<div class="clue-list"><h4>Across</h4><ol>';
            for (const [num, clue] of Object.entries(crosswordData.across)) {
                gridHTML += `<li>${num}. ${clue.clue}</li>`;
            }
            gridHTML += '</ol></div>';
            
            gridHTML += '<div class="clue-list"><h4>Down</h4><ol>';
            for (const [num, clue] of Object.entries(crosswordData.down)) {
                gridHTML += `<li>${num}. ${clue.clue}</li>`;
            }
            gridHTML += '</ol></div>';
            gridHTML += '</div>';
            
            // Add success message area
            gridHTML += `
                <div id="crossword-success" class="crossword-success">
                    Puzzle solved! The password is "EUREKA" (from the first word in 1 Across)
                </div>
                <button class="interaction-button" onclick="showComputerInteraction(event)">Back to Computer</button>
            `;
            
            gridHTML += '</div>';
            
            showModal("Computer Login - Crossword Puzzle", gridHTML, '');
            
            // If using hints, lock the first row and column
            if (withHints) {
                for (let i = 0; i < 5; i++) {
                    document.getElementById(`cell-0-${i}`).readOnly = true;
                    document.getElementById(`cell-${i}-0`).readOnly = true;
                }
            }
        }

        // Check if crossword is completed correctly
        function checkCrosswordCompletion() {
    let allCorrect = true;
    
    for (let row = 0; row < 5; row++) {
        for (let col = 0; col < 5; col++) {
            const cell = document.getElementById(`cell-${row}-${col}`);
            if (!cell.readOnly && cell.value.toUpperCase() !== crosswordData.solution[row][col]) {
                allCorrect = false;
            }
        }
    }
    
    if (allCorrect) {
        const successDiv = document.getElementById('crossword-success');
        successDiv.innerHTML = `
            <p>Puzzle solved! The last digit of the door code is revealed: ${gameState.doorCode.slice(-1)}☀️</p>
            <p class="story-reveal">The sun symbol matches one of the symbols from the desk note.</p>
        `;
        successDiv.style.display = 'block';
        addClue('computer-password');
        
        // Automatically log in after a short delay
        setTimeout(loginToComputer, 1500);
    }
}

        function loginToComputer() {
            addClue('computer-login');
            
            const result = `
                <p>Login successful! The screen displays:</p>
                <div style="font-family: monospace; background: #000; color: #0f0; padding: 10px;">
                    PROJECT PHOENIX - MAIN SYSTEM<br><br>
                    EMERGENCY OVERRIDE CODE: ${gameState.doorCode}<br>
                    Use only if primary systems fail.
                </div>
            `;
            
            showModal("Computer System", result, `<button class="interaction-button" onclick="showComputerInteraction(event)">Back to Computer</button>`);
        }

        function insertUSB(e) {
    if (e) e.stopPropagation();
    if (gameState.inventory.includes('usb-drive')) {
        addClue('usb-inserted');
        
        const result = `
            <p>The USB drive contains Project Phoenix files, including the emergency door code: ${gameState.doorCode}</p>
            <p class="story-reveal">The files mention "Subject 314" and "cellular regeneration".</p>
            <p>The computer now allows login attempts.</p>
        `;
        
        showModal("USB Drive Contents", result, `
            <button class="interaction-button" onclick="showCrosswordPuzzle(event, true)">Attempt Login</button>
            <button class="interaction-button" onclick="showComputerInteraction(event)">Back to Computer</button>
        `);
    }
}


        function attemptCrosswordAccess(e) {
    if (e) e.stopPropagation();

    if (gameState.clues.includes('usb-inserted')) {
        showCrosswordPuzzle(e, false); // No hints even with USB
    } else {
        showModal("Access Denied", `
            <p>You try to access the crossword puzzle, but it's locked.</p>
            <p class="hint">You need to insert a USB drive first to attempt login.</p>
        `, `
            <button class="interaction-button" onclick="modal.style.display='none'">Close</button>
        `);
    }
}


        function showWhiteboardInteraction() {
            addClue('whiteboard-examined');
            
            const result = `
                <p>The whiteboard is covered in equations and the number "314" appears repeatedly.</p>
                <p class="story-reveal">A small note reads: 'Subject 314 showed promise for 314 minutes before deterioration.'</p>
            `;
            
            showModal("Whiteboard", result, `<button class="interaction-button" onclick="modal.style.display='none'">Close</button>`);
        }

        function showChartInteraction() {
            addClue('chart-examined');
            
            const result = `
                <p>The periodic table has certain elements circled with notes about "stabilization sequence".</p>
                <p class="story-reveal">The word "POSSESS" is written vertically beside the elements.</p>
            `;
            
            showModal("Chemical Chart", result, `<button class="interaction-button" onclick="modal.style.display='none'">Close</button>`);
        }

        // Raycaster for object interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        function onMouseClick(event) {
            // Don't process clicks if modal is open
            if (modal.style.display === 'flex') return;
            
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update the raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Calculate objects intersecting the raycaster
            const intersects = raycaster.intersectObjects(interactiveObjects, true); // Note the 'true' for recursive checking
            
            if (intersects.length > 0) {
                // Find the first object with an onClick handler
                let clickedObj = intersects[0].object;
                while (clickedObj && !clickedObj.userData.onClick) {
                    clickedObj = clickedObj.parent;
                }
                
                if (clickedObj && clickedObj.userData.onClick) {
                    clickedObj.userData.onClick();
                }
            }
        }

        window.addEventListener('click', onMouseClick, false);

        // Add to your existing raycaster code
let lastHovered = null;

function onMouseMove(event) {
    // Calculate mouse position
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    
    // Update the raycaster
    raycaster.setFromCamera(mouse, camera);
    
    // Find intersected objects
    const intersects = raycaster.intersectObjects(interactiveObjects, true);
    
    // Remove hover effect from previous object
    if (lastHovered) {
        lastHovered.material.emissive.setHex(lastHovered.userData.originalEmissive || 0x000000);
        lastHovered = null;
    }
    
    // Add hover effect to new object
    if (intersects.length > 0) {
        let hoveredObj = intersects[0].object;
        while (hoveredObj && !hoveredObj.userData.name) {
            hoveredObj = hoveredObj.parent;
        }
        
        if (hoveredObj && hoveredObj.userData.name) {
            // Store original emissive color if not already stored
            if (hoveredObj.material && !hoveredObj.userData.originalEmissive) {
                hoveredObj.userData.originalEmissive = hoveredObj.material.emissive.getHex();
            }
            
            // Apply hover effect
            if (hoveredObj.material) {
                hoveredObj.material.emissive.setHex(0x333333);
            }
            
            lastHovered = hoveredObj;
            
            // Show tooltip
            showTooltip(hoveredObj.userData.name, event.clientX, event.clientY);
        }
    } else {
        hideTooltip();
    }
}

// Tooltip element
const tooltip = document.createElement('div');
tooltip.style.position = 'absolute';
tooltip.style.pointerEvents = 'none';
tooltip.style.backgroundColor = 'rgba(0,0,0,0.7)';
tooltip.style.color = 'white';
tooltip.style.padding = '5px 10px';
tooltip.style.borderRadius = '3px';
tooltip.style.fontFamily = 'Courier New, monospace';
tooltip.style.zIndex = '100';
tooltip.style.display = 'none';
document.body.appendChild(tooltip);

function showTooltip(text, x, y) {
    tooltip.textContent = text;
    tooltip.style.display = 'block';
    tooltip.style.left = (x + 15) + 'px';
    tooltip.style.top = (y + 15) + 'px';
}

function hideTooltip() {
    tooltip.style.display = 'none';
}

window.addEventListener('mousemove', onMouseMove, false);

// Add this after your interactive objects are created
function addInteractionIndicators() {
    interactiveObjects.forEach(obj => {
        // Skip if already has an indicator
        if (obj.userData.hasIndicator) return;
        
        // Create a small sphere indicator
        const indicator = new THREE.Mesh(
            new THREE.SphereGeometry(0.05, 8, 8),
            new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                transparent: true,
                opacity: 0.7
            })
        );
        
        // Position above the object
        const box = new THREE.Box3().setFromObject(obj);
        const size = box.getSize(new THREE.Vector3());
        indicator.position.copy(obj.position);
        indicator.position.y += size.y * 0.6;
        
        // Make it pulse
        function pulse() {
            gsap.to(indicator.scale, {
                x: 1.2,
                y: 1.2,
                z: 1.2,
                duration: 0.5,
                yoyo: true,
                repeat: -1
            });
            gsap.to(indicator.material, {
                opacity: 0.3,
                duration: 0.5,
                yoyo: true,
                repeat: -1
            });
        }
        
        scene.add(indicator);
        pulse();
        
        // Store reference
        obj.userData.indicator = indicator;
        obj.userData.hasIndicator = true;
    });
}

// Call this after creating all interactive objects
addInteractionIndicators();

        // Initialize the game
        updateInventory();
    </script>
</body>
</html>